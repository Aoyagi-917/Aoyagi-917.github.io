<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è¯„è®ºç³»ç»Ÿ</title>
    <!-- å¼•å…¥Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- é…ç½®Tailwindè‡ªå®šä¹‰é¢œè‰² -->
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#3b82f6',
                        secondary: '#64748b',
                        neutral: '#f1f5f9',
                    },
                }
            }
        }
    </script>
    
    <!-- è‡ªå®šä¹‰å·¥å…·ç±» -->
    <style type="text/tailwindcss">
        @layer utilities {
            .comment-shadow {
                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.08);
            }
            .reply-indent {
                margin-left: 1.5rem;
                border-left: 2px solid #e2e8f0;
                padding-left: 1rem;
            }
            .glass-effect {
                background: rgba(255, 255, 255, 0.85);
                backdrop-filter: blur(8px);
            }
            .collapsed-content {
                display: -webkit-box;
                -webkit-line-clamp: 4;
                -webkit-box-orient: vertical;
                overflow: hidden;
            }
            .image-loading {
                background: #f1f5f9;
                animation: pulse 1.5s infinite;
            }
            @keyframes pulse {
                0%, 100% { opacity: 1; }
                50% { opacity: 0.5; }
            }
            .error-message {
                color: #ef4444;
                font-size: 0.875rem;
                margin-top: 0.25rem;
            }
        }
    </style>
</head>
<body class="min-h-screen p-4 md:p-8 bg-cover bg-center bg-fixed" style="background-image: url('https://img.cdn1.vip/i/68e1c60914798_1759626761.webp');">
    <div class="max-w-3xl mx-auto glass-effect rounded-xl p-6 shadow-lg">
        <h1 class="text-2xl font-bold text-gray-800 mb-6">è¯„è®ºåŒº</h1>
        
        <!-- ç”¨æˆ·ä¿¡æ¯åŒº -->
        <div class="flex items-center gap-4 mb-6">
            <div class="relative">
                <img id="user-avatar" 
                     src="https://img.ixintu.com/download/jpg/20200901/3e9ce3813b7199ea9588eeb920f41208_512_512.jpg!bg" 
                     alt="ç”¨æˆ·å¤´åƒ" 
                     class="w-12 h-12 rounded-full object-cover border-2 border-primary image-loading"
                     onload="this.classList.remove('image-loading')">
                <label for="avatar-upload" class="absolute bottom-0 right-0 bg-primary text-white rounded-full w-5 h-5 flex items-center justify-center cursor-pointer text-xs">
                    <span>âœï¸</span>
                </label>
                <input type="file" id="avatar-upload" accept="image/*" class="hidden">
            </div>
            <div>
                <div class="flex items-center gap-2">
                    <span id="current-username" class="font-semibold"></span>
                    <button id="change-username" class="text-primary text-sm hover:underline">ä¿®æ”¹</button>
                </div>
            </div>
        </div>
        
        <!-- è¯„è®ºè¾“å…¥åŒº -->
        <div class="mb-8 bg-neutral/90 rounded-lg p-4">
            <div class="mb-4">
                <label for="comment-content" class="block text-sm font-medium text-gray-700 mb-1">è¯„è®ºå†…å®¹</label>
                <textarea 
                    id="comment-content" 
                    rows="3" 
                    class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-primary/50"
                    placeholder="åˆ†äº«ä½ çš„æƒ³æ³•..."></textarea>
                <div id="content-error" class="error-message hidden">è¯·è¾“å…¥è¯„è®ºå†…å®¹</div>
            </div>
            
            <!-- æ–‡ä»¶ä¸Šä¼ åŒºåŸŸ -->
            <div class="mb-4">
                <label class="block text-sm font-medium text-gray-700 mb-1">é™„ä»¶</label>
                <div class="flex gap-3">
                    <div class="flex-1">
                        <label class="flex items-center justify-center w-full p-3 border-2 border-dashed border-gray-300 rounded-md cursor-pointer bg-white/50 hover:bg-white transition-colors">
                            <span class="text-sm text-gray-500">ä¸Šä¼ å›¾ç‰‡æˆ–æ–‡æ¡£ (â‰¤10MB)</span>
                            <input type="file" id="file-upload" class="hidden" 
                                   accept="image/*,.pptx,.ppt,.docx,.doc,.txt">
                        </label>
                    </div>
                    <div class="flex-1">
                        <input type="text" id="link-upload" 
                               class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-primary/50"
                               placeholder="æˆ–è¾“å…¥é“¾æ¥">
                    </div>
                </div>
                <div id="file-preview" class="mt-2 hidden"></div>
                <div id="file-error" class="error-message hidden"></div>
            </div>
            
            <button id="submit-comment" class="bg-primary text-white px-4 py-2 rounded-md hover:bg-primary/90 transition-colors">
                å‘å¸ƒè¯„è®º
            </button>
            <span id="posting-status" class="ml-2 text-sm text-red-500 hidden"></span>
        </div>
        
        <!-- è¯„è®ºåˆ—è¡¨ -->
        <div id="comments-container" class="space-y-6">
            <!-- è¯„è®ºä¼šé€šè¿‡JSåŠ¨æ€ç”Ÿæˆ -->
            <div class="text-center text-gray-500 py-8" id="empty-state">
                <span class="text-4xl mb-2 opacity-30">ğŸ’¬</span>
                <p>è¿˜æ²¡æœ‰è¯„è®ºï¼Œå¿«æ¥æŠ¢æ²™å‘å§~</p>
            </div>
        </div>
        
        <!-- åˆ†é¡µæ§ä»¶ -->
        <div id="pagination" class="flex justify-center mt-8 gap-2 hidden">
            <button id="prev-page" class="px-3 py-1 border rounded-md hover:bg-gray-100 disabled:opacity-50 disabled:cursor-not-allowed">ä¸Šä¸€é¡µ</button>
            <span id="page-info" class="px-3 py-1"></span>
            <button id="next-page" class="px-3 py-1 border rounded-md hover:bg-gray-100 disabled:opacity-50 disabled:cursor-not-allowed">ä¸‹ä¸€é¡µ</button>
        </div>
    </div>

    <!-- ä¿®æ”¹æ˜µç§°æ¨¡æ€æ¡† -->
    <div id="username-modal" class="fixed inset-0 bg-black/50 flex items-center justify-center z-50 hidden">
        <div class="bg-white rounded-lg p-6 w-full max-w-sm">
            <h3 class="text-lg font-semibold mb-4">ä¿®æ”¹æ˜µç§°</h3>
            <input type="text" id="new-username" class="w-full px-3 py-2 border border-gray-300 rounded-md mb-4" placeholder="æ–°æ˜µç§°">
            <div class="flex justify-end gap-2">
                <button id="cancel-username" class="px-4 py-2 border rounded-md hover:bg-gray-100">å–æ¶ˆ</button>
                <button id="confirm-username" class="px-4 py-2 bg-primary text-white rounded-md hover:bg-primary/90">ç¡®è®¤</button>
            </div>
        </div>
    </div>

    <script>
        // é…ç½®
        const DEFAULT_AVATAR = 'https://img.ixintu.com/download/jpg/20200901/3e9ce3813b7199ea9588eeb920f41208_512_512.jpg!bg';
        const MAX_COMMENTS = 50; // é™åˆ¶æœ€å¤§è¯„è®ºæ•°é‡
        const MAX_FILE_SIZE = 10 * 1024 * 1024; // é™åˆ¶æ–‡ä»¶å¤§å°ä¸º10MB
        const MAX_IMAGE_SIZE = 200 * 1024; // å›¾ç‰‡æœ€å¤§200KB
        const IMAGE_QUALITY = 0.7; // å›¾ç‰‡å‹ç¼©è´¨é‡
        
        // ç”¨æˆ·æ•°æ®åˆå§‹åŒ–
        function initUserData() {
            let userData = JSON.parse(localStorage.getItem('userData') || '{}');
            
            // æ£€æŸ¥æ˜¯å¦æ˜¯æ–°ç”¨æˆ·
            if (!userData.username) {
                const username = prompt('æ¬¢è¿æ¥åˆ°è¯„è®ºåŒºï¼Œè¯·è®¾ç½®æ‚¨çš„æ˜µç§°ï¼š');
                if (username && username.trim()) {
                    userData.username = username.trim();
                } else {
                    userData.username = 'åŒ¿åç”¨æˆ·' + Math.floor(Math.random() * 1000);
                }
                userData.avatar = DEFAULT_AVATAR;
            }
            
            // åˆå§‹åŒ–è¯„è®ºè®°å½•
            if (!localStorage.getItem('commentHistory')) {
                localStorage.setItem('commentHistory', JSON.stringify([]));
            }
            
            // åˆå§‹åŒ–è¯„è®ºå­˜å‚¨
            initCommentStorage();
            
            localStorage.setItem('userData', JSON.stringify(userData));
            return userData;
        }
        
        // åˆå§‹åŒ–è¯„è®ºå­˜å‚¨ï¼Œç¡®ä¿ä¸ä¼šè¶…è¿‡é™åˆ¶
        function initCommentStorage() {
            if (!localStorage.getItem('comments')) {
                localStorage.setItem('comments', JSON.stringify([]));
                return;
            }
            
            // æ£€æŸ¥å¹¶æ¸…ç†æ—§è¯„è®º
            const comments = JSON.parse(localStorage.getItem('comments') || '[]');
            if (comments.length > MAX_COMMENTS) {
                // åªä¿ç•™æœ€æ–°çš„MAX_COMMENTSæ¡è¯„è®º
                const trimmedComments = comments.slice(0, MAX_COMMENTS);
                try {
                    localStorage.setItem('comments', JSON.stringify(trimmedComments));
                } catch (e) {
                    console.warn('æ¸…ç†è¯„è®ºæ—¶å‘ç”Ÿé”™è¯¯ï¼Œå°†å°è¯•è¿›ä¸€æ­¥å‡å°‘å­˜å‚¨:', e);
                    // è¿›ä¸€æ­¥å‡å°‘è¯„è®ºæ•°é‡
                    localStorage.setItem('comments', JSON.stringify(trimmedComments.slice(0, MAX_COMMENTS / 2)));
                }
            }
        }
        
        // å®‰å…¨åœ°ä¿å­˜æ•°æ®åˆ°localStorage
        function safeSetItem(key, value) {
            try {
                localStorage.setItem(key, value);
                return true;
            } catch (e) {
                if (e.name === 'QuotaExceededError') {
                    console.error('å­˜å‚¨é…é¢ä¸è¶³ï¼Œå°è¯•æ¸…ç†æ—§æ•°æ®:', e);
                    
                    // å°è¯•æ¸…ç†æœ€æ—§çš„è¯„è®º
                    if (key === 'comments') {
                        const comments = JSON.parse(value || '[]');
                        // å¦‚æœè¿˜æœ‰è¯„è®ºå¯ä»¥æ¸…ç†
                        if (comments.length > 1) {
                            // ç§»é™¤æœ€æ—§çš„ä¸€æ¡è¯„è®º
                            const newComments = comments.slice(0, comments.length - 1);
                            return safeSetItem(key, JSON.stringify(newComments));
                        }
                    }
                    
                    // å°è¯•æ¸…ç†è¯„è®ºå†å²
                    if (key !== 'commentHistory') {
                        localStorage.setItem('commentHistory', JSON.stringify([]));
                        return safeSetItem(key, value);
                    }
                }
                return false;
            }
        }
        
        // è·å–å½“å‰ç”¨æˆ·æ•°æ®
        function getUserData() {
            return JSON.parse(localStorage.getItem('userData') || '{}');
        }
        
        // ä¿å­˜ç”¨æˆ·æ•°æ®
        function saveUserData(data) {
            safeSetItem('userData', JSON.stringify(data));
        }
        
        // åˆ†é¡µé…ç½®
        const PAGE_SIZE = 10;
        let currentPage = 1;
        let currentUser = initUserData();

        // æ›´æ–°ç”¨æˆ·ä¿¡æ¯æ˜¾ç¤º
        function updateUserDisplay() {
            document.getElementById('current-username').textContent = currentUser.username;
            document.getElementById('user-avatar').src = currentUser.avatar || DEFAULT_AVATAR;
        }

        // è·å–å½“å‰æ—¶é—´
        function getCurrentTime() {
            const now = new Date();
            return now.toISOString().slice(0, 19).replace('T', ' ');
        }

        // ç”Ÿæˆå”¯ä¸€ID
        function generateId() {
            return Date.now().toString(36) + Math.random().toString(36).substr(2, 5);
        }

        // æ£€æŸ¥æ˜¯å¦å¯ä»¥å‘å¸ƒè¯„è®ºï¼ˆé˜²åˆ·å±ï¼‰
        function canPostComment() {
            const history = JSON.parse(localStorage.getItem('commentHistory') || '[]');
            const now = new Date().getTime();
            const twoMinutes = 2 * 60 * 1000; // 2åˆ†é’Ÿçš„æ¯«ç§’æ•°
            
            // è¿‡æ»¤æ‰2åˆ†é’Ÿå‰çš„è®°å½•
            const recentHistory = history.filter(timestamp => now - timestamp < twoMinutes);
            
            // å¦‚æœæœ€è¿‘2åˆ†é’Ÿå†…å‘å¸ƒè¶…è¿‡7æ¡ï¼Œè¿”å›å‰©ä½™ç­‰å¾…æ—¶é—´
            if (recentHistory.length >= 7) {
                const oldestInWindow = Math.min(...recentHistory);
                const waitTime = twoMinutes - (now - oldestInWindow);
                return { canPost: false, waitTime: Math.ceil(waitTime / 1000) };
            }
            
            return { canPost: true };
        }

        // è®°å½•è¯„è®ºå‘å¸ƒæ—¶é—´
        function recordCommentTime() {
            const history = JSON.parse(localStorage.getItem('commentHistory') || '[]');
            // åªä¿ç•™æœ€è¿‘100æ¡è®°å½•
            if (history.length > 100) {
                history.splice(0, history.length - 100);
            }
            history.push(new Date().getTime());
            safeSetItem('commentHistory', JSON.stringify(history));
        }

        // æ£€æŸ¥æ˜¯å¦æ˜¯è¯„è®ºä½œè€…
        function isCommentAuthor(commentAuthor) {
            return commentAuthor === currentUser.username;
        }

        // æ£€æŸ¥è¯„è®ºæ˜¯å¦å¯ä»¥æ’¤å›ï¼ˆåªæœ‰ä½œè€…å¯ä»¥æ’¤å›ï¼‰
        function canWithdraw(comment) {
            return isCommentAuthor(comment.author);
        }

        // è·å–å½“å‰é¡µçš„è¯„è®º
        function getCurrentPageComments() {
            const comments = JSON.parse(localStorage.getItem('comments') || '[]');
            const startIndex = (currentPage - 1) * PAGE_SIZE;
            const endIndex = startIndex + PAGE_SIZE;
            return comments.slice(startIndex, endIndex);
        }

        // è·å–æ€»é¡µæ•°
        function getTotalPages() {
            const comments = JSON.parse(localStorage.getItem('comments') || '[]');
            return Math.ceil(comments.length / PAGE_SIZE);
        }

        // æ›´æ–°åˆ†é¡µæ§ä»¶çŠ¶æ€
        function updatePagination() {
            const totalPages = getTotalPages();
            const paginationEl = document.getElementById('pagination');
            const prevBtn = document.getElementById('prev-page');
            const nextBtn = document.getElementById('next-page');
            const pageInfo = document.getElementById('page-info');

            paginationEl.classList.toggle('hidden', totalPages <= 1);
            
            if (totalPages <= 1) return;

            pageInfo.textContent = `ç¬¬ ${currentPage} / ${totalPages} é¡µ`;
            prevBtn.disabled = currentPage === 1;
            nextBtn.disabled = currentPage === totalPages;
        }

        // æ£€æŸ¥è¯„è®ºæ˜¯å¦éœ€è¦æŠ˜å 
        function needsCollapsing(content) {
            // ç®€å•åˆ¤æ–­ï¼šè¶…è¿‡4è¡Œæˆ–ç‰¹å®šå­—ç¬¦æ•°
            const lineCount = (content.match(/\n/g) || []).length + 1;
            return lineCount > 4 || content.length > 200;
        }

        // æ¸²æŸ“è¯„è®ºåˆ—è¡¨
        function renderComments() {
            const commentsContainer = document.getElementById('comments-container');
            const allComments = JSON.parse(localStorage.getItem('comments') || '[]');
            const currentComments = getCurrentPageComments();
            const emptyState = document.getElementById('empty-state');

            // æ¸…ç©ºå®¹å™¨ï¼ˆä¿ç•™empty-stateï¼‰
            Array.from(commentsContainer.children).forEach(child => {
                if (child.id !== 'empty-state') child.remove();
            });

            // æ˜¾ç¤º/éšè—ç©ºçŠ¶æ€
            emptyState.style.display = allComments.length === 0 ? 'block' : 'none';

            // æ¸²æŸ“å½“å‰é¡µçš„æ¯æ¡è¯„è®º
            currentComments.forEach(comment => {
                const commentEl = createCommentElement(comment);
                commentsContainer.appendChild(commentEl);
            });

            updatePagination();
        }

        // åˆ›å»ºé™„ä»¶æ˜¾ç¤ºå…ƒç´ 
        function createAttachmentsElement(attachments) {
            if (!attachments || attachments.length === 0) return '';
            
            let html = '<div class="mt-2 space-y-1">';
            attachments.forEach(attach => {
                if (attach.type === 'file') {
                    const isImage = attach.mimeType.startsWith('image/');
                    // ä¸ºå›¾ç‰‡æ·»åŠ åŠ è½½çŠ¶æ€å’Œé”™è¯¯å¤„ç†
                    const imageAttrs = isImage ? `
                        class="w-16 h-16 object-cover rounded image-loading"
                        onload="this.classList.remove('image-loading')"
                        onerror="this.src='${DEFAULT_AVATAR}'; this.classList.remove('image-loading')"
                    ` : '';
                    
                    html += `
                        <div class="flex items-center gap-2 p-2 bg-gray-50 rounded">
                            ${isImage ? 
                                `<img src="${attach.url}" alt="é™„ä»¶å›¾ç‰‡" ${imageAttrs}>` : 
                                `<span class="text-gray-500">ğŸ“„</span>`
                            }
                            <div>
                                <div class="text-sm">${attach.name}</div>
                                <a href="${attach.url}" target="_blank" class="text-xs text-primary hover:underline">æŸ¥çœ‹</a>
                            </div>
                        </div>
                    `;
                } else if (attach.type === 'link') {
                    // æ£€æŸ¥æ˜¯å¦æ˜¯å›¾ç‰‡é“¾æ¥
                    const isImageLink = attach.url.match(/\.(jpeg|jpg|gif|png|webp)$/i);
                    html += `
                        <div class="flex items-center gap-2 p-2 bg-gray-50 rounded">
                            ${isImageLink ? 
                                `<img src="${attach.url}" alt="é“¾æ¥å›¾ç‰‡" class="w-16 h-16 object-cover rounded image-loading"
                                    onload="this.classList.remove('image-loading')"
                                    onerror="this.src='${DEFAULT_AVATAR}'; this.classList.remove('image-loading')">` : 
                                `<span class="text-gray-500">ğŸ”—</span>`
                            }
                            <a href="${attach.url}" target="_blank" class="text-sm text-primary hover:underline break-all">${attach.url}</a>
                        </div>
                    `;
                }
            });
            html += '</div>';
            return html;
        }

        // åˆ›å»ºå•æ¡è¯„è®ºå…ƒç´ 
        function createCommentElement(comment, isReply = false) {
            const div = document.createElement('div');
            div.className = `comment-shadow rounded-lg p-4 bg-white/90 ${isReply ? 'reply-indent mt-3' : ''}`;
            div.dataset.id = comment.id;

            // ç¡®ä¿å¿…è¦å±æ€§å­˜åœ¨
            comment.replies = comment.replies || [];
            comment.showAllReplies = comment.showAllReplies || false;
            comment.attachments = comment.attachments || [];
            comment.showFullContent = comment.showFullContent || false;
            
            // æ£€æŸ¥æ˜¯å¦å¯ä»¥æ’¤å›
            const withdrawable = canWithdraw(comment);
            
            // å¤„ç†å›å¤æŠ˜å é€»è¾‘
            const replies = comment.replies;
            const showAllReplies = comment.showAllReplies;
            const visibleReplies = showAllReplies ? replies : replies.slice(0, 3);
            const hasMoreReplies = replies.length > 3;
            
            // å¤„ç†é•¿è¯„è®ºæŠ˜å 
            const contentNeedsCollapsing = needsCollapsing(comment.content);
            const showFullContent = comment.showFullContent;
            
            // å¤´åƒåŠ è½½å¤„ç†
            const avatarSrc = comment.avatar || DEFAULT_AVATAR;
            
            div.innerHTML = `
                <div class="flex gap-3 mb-2">
                    <img src="${avatarSrc}" 
                         alt="${comment.author}çš„å¤´åƒ" 
                         class="w-8 h-8 rounded-full object-cover image-loading"
                         onload="this.classList.remove('image-loading')"
                         onerror="this.src='${DEFAULT_AVATAR}'; this.classList.remove('image-loading')">
                    <div class="flex-1">
                        <div class="flex justify-between items-start">
                            <h3 class="font-semibold text-gray-800">${comment.author}</h3>
                            <span class="text-xs text-gray-500">${comment.time}</span>
                        </div>
                        <div class="text-gray-700 mb-2 ${contentNeedsCollapsing && !showFullContent ? 'collapsed-content' : ''}">
                            ${comment.content}
                        </div>
                        ${contentNeedsCollapsing ? `
                            <button class="toggle-content text-sm text-primary mb-2" data-id="${comment.id}">
                                ${showFullContent ? 'æ”¶èµ·' : 'å±•å¼€å…¨éƒ¨'}
                            </button>
                        ` : ''}
                        ${createAttachmentsElement(comment.attachments)}
                    </div>
                </div>
                <div class="flex items-center gap-4 text-sm">
                    <button class="like-btn flex items-center gap-1 text-gray-600 hover:text-red-500 transition-colors" 
                            data-id="${comment.id}">
                        <span>${comment.isLiked ? 'â¤ï¸' : 'ğŸ¤'}</span>
                        <span>${comment.likes}</span>
                    </button>
                    <button class="reply-btn flex items-center gap-1 text-gray-600 hover:text-primary transition-colors">
                        <span>ğŸ’¬</span>
                        <span>å›å¤</span>
                    </button>
                    ${withdrawable ? `
                    <button class="withdraw-btn flex items-center gap-1 text-gray-600 hover:text-red-500 transition-colors">
                        <span>ğŸ—‘ï¸</span>
                        <span>æ’¤å›</span>
                    </button>
                    ` : ''}
                </div>
                <!-- å›å¤è¾“å…¥æ¡†ï¼ˆé»˜è®¤éšè—ï¼‰ -->
                <div class="reply-form mt-3 hidden">
                    <textarea class="reply-content w-full px-3 py-2 border border-gray-300 rounded-md text-sm focus:outline-none focus:ring-2 focus:ring-primary/50"
                              rows="2" placeholder="å›å¤ @${comment.author}..."></textarea>
                    <div class="mt-2">
                        <label class="text-xs text-gray-500">æ·»åŠ é™„ä»¶</label>
                        <input type="file" class="reply-file-upload hidden" accept="image/*,.pptx,.ppt,.docx,.doc,.txt">
                        <label for="reply-file-${comment.id}" class="text-xs text-primary cursor-pointer hover:underline">ä¸Šä¼ æ–‡ä»¶</label>
                        <input type="text" class="reply-link ml-2 px-2 py-1 border border-gray-300 rounded text-xs w-48" placeholder="æˆ–è¾“å…¥é“¾æ¥">
                        <input type="file" id="reply-file-${comment.id}" class="reply-file-upload hidden" accept="image/*,.pptx,.ppt,.docx,.doc,.txt">
                    </div>
                    <div class="flex gap-2 mt-2">
                        <button class="submit-reply bg-primary/90 text-white px-3 py-1 rounded-md text-sm hover:bg-primary transition-colors">
                            å›å¤
                        </button>
                        <button class="cancel-reply text-gray-500 px-3 py-1 rounded-md text-sm hover:bg-gray-100 transition-colors">
                            å–æ¶ˆ
                        </button>
                    </div>
                </div>
                <!-- å›å¤åˆ—è¡¨ -->
                <div class="replies mt-4 space-y-2">
                    ${visibleReplies.map(reply => createCommentElement(reply, true).outerHTML).join('')}
                    ${hasMoreReplies ? `
                        <button class="toggle-replies text-sm text-primary mt-1 flex items-center gap-1" data-id="${comment.id}">
                            <span>â¬‡ï¸</span>
                            <span>æ˜¾ç¤º${showAllReplies ? 'æ›´å°‘' : 'å…¨éƒ¨'}å›å¤ (${showAllReplies ? 3 : replies.length - 3}æ¡)</span>
                        </button>
                    ` : ''}
                </div>
            `;

            // ç»‘å®šå›å¤æŠ˜å /å±•å¼€äº‹ä»¶
            if (hasMoreReplies) {
                const toggleBtn = div.querySelector('.toggle-replies');
                toggleBtn.addEventListener('click', function() {
                    const commentId = this.dataset.id;
                    toggleRepliesVisibility(commentId);
                });
            }

            // ç»‘å®šå†…å®¹æŠ˜å /å±•å¼€äº‹ä»¶
            if (contentNeedsCollapsing) {
                const toggleBtn = div.querySelector('.toggle-content');
                toggleBtn.addEventListener('click', function() {
                    const commentId = this.dataset.id;
                    toggleContentVisibility(commentId);
                });
            }

            return div;
        }

        // å†…å®¹æŠ˜å /å±•å¼€å‡½æ•°
        function toggleContentVisibility(commentId) {
            const comments = JSON.parse(localStorage.getItem('comments') || '[]');
            
            // é€’å½’æŸ¥æ‰¾è¯„è®ºå¹¶åˆ‡æ¢æ˜¾ç¤ºçŠ¶æ€
            function findAndToggle(commentList) {
                for (let comment of commentList) {
                    if (comment.id === commentId) {
                        comment.showFullContent = !comment.showFullContent;
                        return true;
                    }
                    if (comment.replies && comment.replies.length > 0) {
                        if (findAndToggle(comment.replies)) {
                            return true;
                        }
                    }
                }
                return false;
            }
            
            findAndToggle(comments);
            safeSetItem('comments', JSON.stringify(comments));
            renderComments();
        }

        // å›å¤æŠ˜å /å±•å¼€å‡½æ•°
        function toggleRepliesVisibility(commentId) {
            const comments = JSON.parse(localStorage.getItem('comments') || '[]');
            
            // é€’å½’æŸ¥æ‰¾è¯„è®ºå¹¶åˆ‡æ¢æ˜¾ç¤ºçŠ¶æ€
            function findAndToggle(commentList) {
                for (let comment of commentList) {
                    if (comment.id === commentId) {
                        comment.showAllReplies = !comment.showAllReplies;
                        return true;
                    }
                    if (comment.replies && comment.replies.length > 0) {
                        if (findAndToggle(comment.replies)) {
                            return true;
                        }
                    }
                }
                return false;
            }
            
            findAndToggle(comments);
            safeSetItem('comments', JSON.stringify(comments));
            renderComments();
        }

        // å‹ç¼©å›¾ç‰‡
        function compressImage(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.readAsDataURL(file);
                
                reader.onload = function(e) {
                    const img = new Image();
                    img.src = e.target.result;
                    
                    img.onload = function() {
                        // åˆ›å»ºcanvaså…ƒç´ 
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        
                        // è®¡ç®—å‹ç¼©åçš„å°ºå¯¸ï¼ˆä¿æŒæ¯”ä¾‹ï¼‰
                        let width = img.width;
                        let height = img.height;
                        const maxDim = 800; // æœ€å¤§å°ºå¯¸é™åˆ¶
                        
                        if (width > height && width > maxDim) {
                            height = (height * maxDim) / width;
                            width = maxDim;
                        } else if (height > maxDim) {
                            width = (width * maxDim) / height;
                            height = maxDim;
                        }
                        
                        canvas.width = width;
                        canvas.height = height;
                        
                        // ç»˜åˆ¶å›¾ç‰‡
                        ctx.drawImage(img, 0, 0, width, height);
                        
                        // è½¬æ¢ä¸ºbase64ï¼Œè®¾ç½®è´¨é‡
                        canvas.toBlob((blob) => {
                            const compressedFile = new File([blob], file.name, { 
                                type: file.type,
                                lastModified: Date.now()
                            });
                            
                            // è¯»å–å‹ç¼©åçš„æ–‡ä»¶
                            const compressedReader = new FileReader();
                            compressedReader.readAsDataURL(compressedFile);
                            compressedReader.onload = function(event) {
                                resolve(event.target.result);
                            };
                        }, file.type, IMAGE_QUALITY);
                    };
                    
                    img.onerror = function() {
                        reject('å›¾ç‰‡åŠ è½½å¤±è´¥');
                    };
                };
                
                reader.onerror = function() {
                    reject('æ–‡ä»¶è¯»å–å¤±è´¥');
                };
            });
        }

        // å¤„ç†æ–‡ä»¶ä¸Šä¼ 
        function handleFileUpload(file) {
            return new Promise((resolve, reject) => {
                // æ£€æŸ¥æ–‡ä»¶å¤§å°
                if (file.size > MAX_FILE_SIZE) {
                    reject(`æ–‡ä»¶å¤§å°ä¸èƒ½è¶…è¿‡${MAX_FILE_SIZE / (1024 * 1024)}MB`);
                    return;
                }
                
                // å¯¹äºå›¾ç‰‡ï¼Œå‹ç¼©åè½¬ä¸ºdataURL
                if (file.type.startsWith('image/')) {
                    // å¦‚æœå›¾ç‰‡è¿‡å¤§ï¼Œå…ˆå‹ç¼©
                    if (file.size > MAX_IMAGE_SIZE) {
                        compressImage(file)
                            .then(compressedDataUrl => {
                                resolve({
                                    type: 'file',
                                    name: file.name,
                                    mimeType: file.type,
                                    url: compressedDataUrl
                                });
                            })
                            .catch(error => {
                                reject(`å›¾ç‰‡å¤„ç†å¤±è´¥: ${error}`);
                            });
                    } else {
                        const reader = new FileReader();
                        reader.onload = function(e) {
                            resolve({
                                type: 'file',
                                name: file.name,
                                mimeType: file.type,
                                url: e.target.result
                            });
                        };
                        reader.onerror = function() {
                            reject('å›¾ç‰‡è¯»å–å¤±è´¥ï¼Œè¯·é‡è¯•');
                        };
                        reader.readAsDataURL(file);
                    }
                } else {
                    // å¯¹äºæ–‡æ¡£ï¼Œä»…ä¿å­˜æ–‡ä»¶åå’Œç±»å‹
                    resolve({
                        type: 'file',
                        name: file.name,
                        mimeType: file.type,
                        url: '#file-' + generateId()
                    });
                }
            });
        }

        // å‘å¸ƒè¯„è®º
        async function publishComment() {
            // æ¸…é™¤ä¹‹å‰çš„é”™è¯¯æç¤º
            document.getElementById('content-error').classList.add('hidden');
            document.getElementById('file-error').classList.add('hidden');
            document.getElementById('posting-status').classList.add('hidden');
            
            const content = document.getElementById('comment-content').value;
            const link = document.getElementById('link-upload').value.trim();
            const fileInput = document.getElementById('file-upload');
            
            // éªŒè¯è¯„è®ºå†…å®¹
            if (!content.trim()) {
                document.getElementById('content-error').classList.remove('hidden');
                return false;
            }

            // æ£€æŸ¥é˜²åˆ·å±é™åˆ¶
            const postCheck = canPostComment();
            if (!postCheck.canPost) {
                const statusEl = document.getElementById('posting-status');
                statusEl.textContent = `è¯„è®ºè¿‡äºé¢‘ç¹ï¼Œè¯·ç­‰å¾…${postCheck.waitTime}ç§’åå†è¯•`;
                statusEl.classList.remove('hidden');
                return false;
            }

            try {
                const attachments = [];
                
                // å¤„ç†æ–‡ä»¶ä¸Šä¼ 
                if (fileInput.files.length > 0) {
                    try {
                        const fileData = await handleFileUpload(fileInput.files[0]);
                        attachments.push(fileData);
                    } catch (error) {
                        document.getElementById('file-error').textContent = error;
                        document.getElementById('file-error').classList.remove('hidden');
                        return false;
                    }
                }
                
                // å¤„ç†é“¾æ¥
                if (link) {
                    attachments.push({
                        type: 'link',
                        url: link
                    });
                }

                const comments = JSON.parse(localStorage.getItem('comments') || '[]');
                const newComment = {
                    id: generateId(),
                    content: content.trim(),
                    author: currentUser.username,
                    avatar: currentUser.avatar,
                    time: getCurrentTime(),
                    likes: 0,
                    isLiked: false,
                    replies: [],
                    showAllReplies: false,
                    showFullContent: false,
                    attachments: attachments || []
                };

                // æ·»åŠ æ–°è¯„è®ºåˆ°å¼€å¤´
                comments.unshift(newComment);
                
                // é™åˆ¶è¯„è®ºæ€»æ•°
                if (comments.length > MAX_COMMENTS) {
                    comments.pop(); // ç§»é™¤æœ€æ—§çš„è¯„è®º
                }

                // å°è¯•ä¿å­˜è¯„è®º
                const saveSuccess = safeSetItem('comments', JSON.stringify(comments));
                if (!saveSuccess) {
                    throw new Error('å­˜å‚¨ç©ºé—´ä¸è¶³ï¼Œæ— æ³•å‘å¸ƒè¯„è®º');
                }
                
                // è®°å½•è¯„è®ºæ—¶é—´
                recordCommentTime();
                
                currentPage = 1;
                renderComments();

                // æ¸…ç©ºè¾“å…¥æ¡†
                document.getElementById('comment-content').value = '';
                document.getElementById('link-upload').value = '';
                document.getElementById('file-preview').classList.add('hidden');
                fileInput.value = '';
                
                return true;
            } catch (error) {
                console.error('å‘å¸ƒè¯„è®ºå¤±è´¥:', error);
                const statusEl = document.getElementById('posting-status');
                statusEl.textContent = error.message;
                statusEl.classList.remove('hidden');
                return false;
            }
        }

        // å‘å¸ƒå›å¤
        async function publishReply(commentId, content, attachments) {
            if (!content.trim()) {
                alert('è¯·è¾“å…¥å›å¤å†…å®¹');
                return;
            }

            // æ£€æŸ¥é˜²åˆ·å±é™åˆ¶
            const postCheck = canPostComment();
            if (!postCheck.canPost) {
                alert(`è¯„è®ºè¿‡äºé¢‘ç¹ï¼Œè¯·ç­‰å¾…${postCheck.waitTime}ç§’åå†è¯•`);
                return;
            }

            try {
                const comments = JSON.parse(localStorage.getItem('comments') || '[]');
                const newReply = {
                    id: generateId(),
                    content: content.trim(),
                    author: currentUser.username,
                    avatar: currentUser.avatar,
                    time: getCurrentTime(),
                    likes: 0,
                    isLiked: false,
                    replies: [],
                    showAllReplies: false,
                    showFullContent: false,
                    attachments: attachments || []
                };

                // é€’å½’æŸ¥æ‰¾è¯„è®ºå¹¶æ·»åŠ å›å¤
                function findAndAddReply(commentList) {
                    for (let i = 0; i < commentList.length; i++) {
                        if (commentList[i].id === commentId) {
                            commentList[i].replies.unshift(newReply);
                            return true;
                        }
                        if (commentList[i].replies && commentList[i].replies.length > 0 && findAndAddReply(commentList[i].replies)) {
                            return true;
                        }
                    }
                    return false;
                }

                findAndAddReply(comments);
                
                // é™åˆ¶è¯„è®ºæ€»æ•°
                if (comments.length > MAX_COMMENTS) {
                    comments.pop(); // ç§»é™¤æœ€æ—§çš„è¯„è®º
                }

                // å°è¯•ä¿å­˜è¯„è®º
                const saveSuccess = safeSetItem('comments', JSON.stringify(comments));
                if (!saveSuccess) {
                    throw new Error('å­˜å‚¨ç©ºé—´ä¸è¶³ï¼Œæ— æ³•å‘å¸ƒå›å¤');
                }
                
                // è®°å½•è¯„è®ºæ—¶é—´
                recordCommentTime();
                
                renderComments();
            } catch (error) {
                console.error('å‘å¸ƒå›å¤å¤±è´¥:', error);
                alert(error.message);
            }
        }

        // ç‚¹èµåŠŸèƒ½
        function toggleLike(commentId) {
            try {
                const comments = JSON.parse(localStorage.getItem('comments') || '[]');

                function findAndToggleLike(commentList) {
                    for (let comment of commentList) {
                        if (comment.id === commentId) {
                            comment.likes += comment.isLiked ? -1 : 1;
                            comment.isLiked = !comment.isLiked;
                            return true;
                        }
                        if (comment.replies && comment.replies.length > 0 && findAndToggleLike(comment.replies)) {
                            return true;
                        }
                    }
                    return false;
                }

                findAndToggleLike(comments);
                safeSetItem('comments', JSON.stringify(comments));
                renderComments();
            } catch (error) {
                console.error('ç‚¹èµå¤±è´¥:', error);
                alert('æ“ä½œå¤±è´¥ï¼Œè¯·ç¨åé‡è¯•');
            }
        }

        // æ’¤å›è¯„è®º/å›å¤åŠŸèƒ½
        function withdrawComment(commentId) {
            if (!confirm('ç¡®å®šè¦æ’¤å›è¿™æ¡è¯„è®ºå—ï¼Ÿ')) {
                return;
            }

            try {
                const comments = JSON.parse(localStorage.getItem('comments') || '[]');

                function findAndRemoveComment(commentList) {
                    for (let i = 0; i < commentList.length; i++) {
                        if (commentList[i].id === commentId) {
                            commentList.splice(i, 1);
                            return true;
                        }
                        if (commentList[i].replies && commentList[i].replies.length > 0 && findAndRemoveComment(commentList[i].replies)) {
                            return true;
                        }
                    }
                    return false;
                }

                findAndRemoveComment(comments);
                safeSetItem('comments', JSON.stringify(comments));
                
                // è°ƒæ•´å½“å‰é¡µ
                const totalPages = getTotalPages();
                if (currentPage > totalPages && totalPages > 0) {
                    currentPage = totalPages;
                }
                
                renderComments();
            } catch (error) {
                console.error('æ’¤å›è¯„è®ºå¤±è´¥:', error);
                alert('æ“ä½œå¤±è´¥ï¼Œè¯·ç¨åé‡è¯•');
            }
        }

        // æ›´æ¢å¤´åƒ
        function changeAvatar(file) {
            return new Promise((resolve, reject) => {
                if (!file.type.startsWith('image/')) {
                    reject('è¯·ä¸Šä¼ å›¾ç‰‡æ–‡ä»¶');
                    return;
                }
                
                // é™åˆ¶å¤´åƒå¤§å°
                if (file.size > MAX_IMAGE_SIZE) {
                    // å‹ç¼©å¤´åƒ
                    compressImage(file)
                        .then(compressedDataUrl => {
                            currentUser.avatar = compressedDataUrl;
                            saveUserData(currentUser);
                            updateUserDisplay();
                            resolve();
                        })
                        .catch(error => {
                            reject(`å¤´åƒå¤„ç†å¤±è´¥: ${error}`);
                        });
                } else {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        currentUser.avatar = e.target.result;
                        saveUserData(currentUser);
                        updateUserDisplay();
                        resolve();
                    };
                    reader.onerror = function() {
                        reject('å¤´åƒè¯»å–å¤±è´¥ï¼Œè¯·é‡è¯•');
                    };
                    reader.readAsDataURL(file);
                }
            });
        }

        // ä¿®æ”¹æ˜µç§°
        function changeUsername(newName) {
            if (!newName || !newName.trim()) {
                alert('è¯·è¾“å…¥æœ‰æ•ˆçš„æ˜µç§°');
                return false;
            }
            
            currentUser.username = newName.trim();
            saveUserData(currentUser);
            updateUserDisplay();
            return true;
        }

        // äº‹ä»¶ç›‘å¬
        document.addEventListener('DOMContentLoaded', () => {
            // åˆå§‹åŒ–ç”¨æˆ·æ˜¾ç¤º
            updateUserDisplay();
            
            // åˆå§‹æ¸²æŸ“è¯„è®º
            renderComments();

            // å‘å¸ƒè¯„è®ºæŒ‰é’®
            document.getElementById('submit-comment').addEventListener('click', publishComment);
            
            // æ·»åŠ é”®ç›˜äº‹ä»¶æ”¯æŒ
            document.getElementById('comment-content').addEventListener('keydown', (e) => {
                // Ctrl+Enter å‘å¸ƒè¯„è®º
                if (e.ctrlKey && e.key === 'Enter') {
                    e.preventDefault();
                    publishComment();
                }
            });

            // æ–‡ä»¶ä¸Šä¼ é¢„è§ˆ
            document.getElementById('file-upload').addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                try {
                    const fileData = await handleFileUpload(file);
                    const previewEl = document.getElementById('file-preview');
                    
                    // å›¾ç‰‡é¢„è§ˆå¤„ç†
                    let previewContent = '';
                    if (fileData.mimeType.startsWith('image/')) {
                        previewContent = `
                            <div class="flex items-center gap-2 p-2 bg-gray-50 rounded">
                                <img src="${fileData.url}" alt="é¢„è§ˆ" class="w-16 h-16 object-cover rounded image-loading"
                                    onload="this.classList.remove('image-loading')"
                                    onerror="this.src='${DEFAULT_AVATAR}'; this.classList.remove('image-loading')">
                                <div class="flex-1">
                                    <div class="text-sm">${fileData.name}</div>
                                    <button id="remove-file" class="text-xs text-red-500 hover:underline">ç§»é™¤</button>
                                </div>
                            </div>
                        `;
                    } else {
                        previewContent = `
                            <div class="flex items-center gap-2 p-2 bg-gray-50 rounded">
                                <span class="text-gray-500">ğŸ“„</span>
                                <div class="flex-1">
                                    <div class="text-sm">${fileData.name}</div>
                                    <button id="remove-file" class="text-xs text-red-500 hover:underline">ç§»é™¤</button>
                                </div>
                            </div>
                        `;
                    }
                    
                    previewEl.innerHTML = previewContent;
                    previewEl.classList.remove('hidden');
                    
                    // ç§»é™¤æ–‡ä»¶
                    document.getElementById('remove-file').addEventListener('click', () => {
                        previewEl.classList.add('hidden');
                        document.getElementById('file-upload').value = '';
                    });
                } catch (error) {
                    document.getElementById('file-error').textContent = error;
                    document.getElementById('file-error').classList.remove('hidden');
                }
            });

            // åˆ†é¡µæŒ‰é’®äº‹ä»¶
            document.getElementById('prev-page').addEventListener('click', () => {
                if (currentPage > 1) {
                    currentPage--;
                    renderComments();
                }
            });

            document.getElementById('next-page').addEventListener('click', () => {
                const totalPages = getTotalPages();
                if (currentPage < totalPages) {
                    currentPage++;
                    renderComments();
                }
            });

            // å¤´åƒä¸Šä¼ 
            document.getElementById('avatar-upload').addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (file) {
                    try {
                        await changeAvatar(file);
                        alert('å¤´åƒæ›´æ–°æˆåŠŸ');
                    } catch (error) {
                        alert(error);
                    }
                    e.target.value = '';
                }
            });

            // ä¿®æ”¹æ˜µç§°ç›¸å…³äº‹ä»¶
            document.getElementById('change-username').addEventListener('click', () => {
                document.getElementById('username-modal').classList.remove('hidden');
                document.getElementById('new-username').value = currentUser.username;
            });

            document.getElementById('cancel-username').addEventListener('click', () => {
                document.getElementById('username-modal').classList.add('hidden');
            });

            document.getElementById('confirm-username').addEventListener('click', () => {
                const newName = document.getElementById('new-username').value;
                if (changeUsername(newName)) {
                    document.getElementById('username-modal').classList.add('hidden');
                }
            });

            // ç‚¹å‡»äº‹ä»¶å§”æ‰˜
            const commentsContainer = document.getElementById('comments-container');
            
            // ç‚¹èµæŒ‰é’®äº‹ä»¶
            commentsContainer.addEventListener('click', (e) => {
                const likeBtn = e.target.closest('.like-btn');
                if (likeBtn) {
                    const commentId = likeBtn.dataset.id;
                    toggleLike(commentId);
                }
            });
            
            // å›å¤æŒ‰é’®äº‹ä»¶
            commentsContainer.addEventListener('click', (e) => {
                const replyBtn = e.target.closest('.reply-btn');
                if (replyBtn) {
                    const commentEl = replyBtn.closest('[data-id]');
                    const replyForm = commentEl.querySelector('.reply-form');
                    // éšè—å…¶ä»–æ‰€æœ‰å›å¤æ¡†
                    document.querySelectorAll('.reply-form').forEach(form => {
                        if (form !== replyForm) form.classList.add('hidden');
                    });
                    // åˆ‡æ¢å½“å‰å›å¤æ¡†æ˜¾ç¤ºçŠ¶æ€
                    replyForm.classList.toggle('hidden');
                }
            });
            
            // å–æ¶ˆå›å¤äº‹ä»¶
            commentsContainer.addEventListener('click', (e) => {
                const cancelBtn = e.target.closest('.cancel-reply');
                if (cancelBtn) {
                    cancelBtn.closest('.reply-form').classList.add('hidden');
                }
            });
            
            // å›å¤æ–‡ä»¶ä¸Šä¼ 
            commentsContainer.addEventListener('change', async (e) => {
                const fileInput = e.target.closest('.reply-file-upload');
                if (fileInput && fileInput.files.length > 0) {
                    try {
                        const fileData = await handleFileUpload(fileInput.files[0]);
                        const replyForm = fileInput.closest('.reply-form');
                        replyForm.dataset.attachment = JSON.stringify([fileData]);
                        alert('æ–‡ä»¶å·²æ·»åŠ ');
                    } catch (error) {
                        alert(error);
                    }
                    fileInput.value = '';
                }
            });
            
            // æäº¤å›å¤äº‹ä»¶
            commentsContainer.addEventListener('click', async (e) => {
                const submitReplyBtn = e.target.closest('.submit-reply');
                if (submitReplyBtn) {
                    const replyForm = submitReplyBtn.closest('.reply-form');
                    const commentEl = replyForm.closest('[data-id]');
                    const commentId = commentEl.dataset.id;
                    const content = replyForm.querySelector('.reply-content').value;
                    const link = replyForm.querySelector('.reply-link').value.trim();
                    
                    const attachments = [];
                    
                    // è·å–æ–‡ä»¶é™„ä»¶
                    if (replyForm.dataset.attachment) {
                        attachments.push(...JSON.parse(replyForm.dataset.attachment));
                        delete replyForm.dataset.attachment;
                    }
                    
                    // å¤„ç†é“¾æ¥
                    if (link) {
                        attachments.push({
                            type: 'link',
                            url: link
                        });
                    }

                    await publishReply(commentId, content, attachments);
                    replyForm.classList.add('hidden');
                    replyForm.querySelector('.reply-content').value = '';
                    replyForm.querySelector('.reply-link').value = '';
                }
            });
            
            // æ’¤å›æŒ‰é’®äº‹ä»¶
            commentsContainer.addEventListener('click', (e) => {
                const withdrawBtn = e.target.closest('.withdraw-btn');
                if (withdrawBtn) {
                    const commentEl = withdrawBtn.closest('[data-id]');
                    const commentId = commentEl.dataset.id;
                    withdrawComment(commentId);
                }
            });
        });
    </script>
</body>
</html>
